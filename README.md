## Client

First update and run the development server:

```bash
npm i
# then
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

## Server and Database

First, inside the server folder:

```bash
npm i
```

Then create a .env file with the following test values:

#### `.env:` 
```ini
DATABASE_URL="postgresql://server:test@localhost:5432/mydb"
JWT_SECRET=EXAMPLE_SECRET_TOKEN
```
    
Run the following commands to setup the database schema:
```bash
npx prisma generate
npx prisma migrate dev --name init
```

`generate` will create the Prisma client.

`migrate dev` will apply the schema to your database and create the tables.

If you're having any issues with setting up Prisma, [view the official docs here](https://www.prisma.io/docs/).

Then run the following to get a local test environment set up using nodemon:
    
```bash
nodemon app.js
```

You should then expect to see the following output:

```bash
[nodemon] starting `node app.js index.js`
âœ… Server is running on http://localhost:4000
```

# Basic Documentation / Writeup



## 0. Documentation Outline
As this is meant to be a more casual overview of my thought process, I'm not going to always specify stuff that I would otherwise, such as inputs and percise utility of functions.

Instead I'll break this up into 4 parts, providing a high level overview of each section:

    1. General Overview
    2. Database Overview
    3. API Server Overview
    4. Client Overview

Since this project is inherently simple, my hope is that there shouldn't be too much need to elaborate heavily on what each individual piece does and instead hearing a general overview of my rationale and thought process should suffice. Of course, should any questions arise, feel free to contact me directly.

## 1. General Overview
This projects architecture is located in 3 core parts:

        Frontend (Next.js)
        Backend / API Server (Express.js)
        Database ORM (Prisma / PostgreSQL)

Anything which may see reuse in each layer is separated out as much as possible, so that the data is accessible by all files in the project without forcing code reuse.

There are located in:

    client/util
    client/constants
    client/components/general
    server/util

Additionally in compliance with best practices, related data is grouped together as much as possible, for instance:

    client/components/(route)
        
will contain all components used specifically in that route which are not shared with other routes.

Further explanation as to the function of each file will be written in later sections.

## 2. Database Overview

The database schema for this project is very simple:

Users:
User objects contain the following fields:

        id        Int      @id @default(autoincrement())
        createdAt DateTime @default(now())
        updatedAt DateTime @updatedAt
        username  String   @unique
        email     String   @unique
        password  String
        entries   String[]

bcrypt handles the password encryption / decryption process.

entries array contains all Note 'generatedKey' values associated with the account for quick lookup as needed (see router.get('/user-notes') located in /server/routes/notes.js for more info)

Notes:
    Note objects contain the following fields:

                id           Int      @id @default(autoincrement())
                generatedKey String @unique
                createdAt    DateTime @default(now())
                updatedAt    DateTime @updatedAt
                updateTimes  String[]
                title       String
                body         String
                owner        String

generatedKey is the primary key that is used to look up note objects internally and is generated by a function in the NoteHandler class upon creation (located in server/util/NoteHandler.js).

'updateTimes' logs the time that any changes are made to the entry

'owner' is assigned on creation to the user creating the note, so that both objects have the ability to find one another independently.

## 3. API Server Overview

Notable libraries:

        JWT / JSON Web Token: Handles the authentication / storing of each user object cookie
        bcrypt: Handles the encryption of user passwords
        prisma/client: Handles interfacing with the database
        multer: Parses data from the client, in this instance most notably the FormData object. In a production environment, this would likely be used for parsing files as well.

The server layer for this project is broken up into 2 core parts:

        1. Authentication Routes
        2. Note Routes

Before diving into those, lets first do a quick overview of the server/util folder:

#### `'authMiddleware.js':`
Contains the middleware function used to verify the users JWT, therefore verifying that users cannot get access to data which does not belong to them.
Function is named authenticateConnection and will be referred to as such moving forward.

#### `'Charset.js':`
Very self explanatory, contains numbers, symbols, and uppercase / lowercase letters for use elsewhere.

#### `'ServerLogger.js':`
Custom wrapper class containing functions for the console.log output.
Adds date / time to all log outputs as well as corresponding emojis to help descern what is happening at a glance.
This exact application of a ServerLogger class isn't always applicable, but in cases where it is I find that it can be quite helpful for quick debugging.

#### `'NoteHandler.js':`
Contains helper functions and values for processing Note objects to help make sure that it's done uniformly and with minimal code reuse.

I find keeping all data related to the processing of Notes as "in one place" as possible to be beneifical in avoiding code reuse and ensuring clarity.

Ex. Should a developer feel the need to change the keyLength value, the value is clearly centralized here.

## 3.1. Authentication Routes:
Note:
    In all instances where the basic logic does not follow (ex. invalid data has been sent to the API route), it should be assumed that the error handling is in place to account for it. Therefore, I will not be manually writing out every time a non successful status is triggered.
    Additionally, using the aforementioned ServerLogger class, all actions should be logged respectively as they're taken.

### `.get('/authenticated_user'):`
    
Uses authenticateConnection middleware.

**Basic Logic:**

- Validates data
- Searches for user
- Sends corresponding data to client.

Note:
    If the client receives anything except a status 200 response, it will redirect the client to login route.

### `.post('/login'):`
Logs in the user. 

Uses multer's upload.none() middleware to parse FormData object from client.

**Basic Logic:**

- Validates data
- Searches for user by email
- Verifies password is correct using bcrypt
- Creates JWT token
- Sends status 201, user token, and user object to client

### `.post('/signup'):`
Signs up the user.

Uses multer's upload.none() middleware to parse FormData object from client.

**Basic Logic:**
- Validates data
- Encrypts password with bcrypt
- Creates user object in database
- Creates new JWT
- Sends status 201, user token, and user object to client


## 3.2. Note Routes:

### `.get('/user-notes'):`
Authenticates user connection and sends array of notes corresponding with users entries array to client.

Uses authenticateConnection middleware.

***Basic Logic:***
- Validates data
- Searches for user by id
- Uses prisma to find all note objects (note use of Promise.all to avoid reopening and closing connection to database on each iteration of the map.() function)
- Filters null objects from Searches
- Sends to client

### `.post('/note'):`
Creates a new note and appends its key to the authenticated user's entries array.

Uses authenticateConnection middleware.
Uses multer's upload.none() middleware to parse FormData object from client.

***Basic Logic:***
- Validates data
- Searches for user by id
- Creates note object
- Saves note using prisma.note.create()
- Appends the note's key to user's entries array with prisma.user.update()

### `.post('update-note'):`
Updates an existing note's title/body and appends an update timestamp.

Uses authenticateConnection middleware.
Uses multer's upload.none() middleware to parse FormData object from client.

***Basic Logic:***
- Validates data
- Looks up note using generatedKey (sent from client)
- Updates corresponding notes: title, body
- Appends new entry to updateTimes via NoteHandler.updateTimeArray()
- Updates database with prisma.note.update()
- Sends new note back to client

### `.post('/delete-note'):`
Searches for note by its generatedKey value, deletes from database and user's entries array

Uses authenticateConnection middleware.
Uses multer's upload.none() middleware to parse FormData object from client.

***Basic Logic:***
- Validates data
- Searches for user by id
- Filters out the generatedKey from user's entries array
- Updates the user with new entries array
- Searches for note using generatedKey and deletes via prisma.note.delete()


## 4. Client Overview

Given that the prompt you outlined for me was not front-end focused, the goal was to make something functional and not overly stylized. Therefore, a lot of the design is simply to make things legible for the user without much other consideration. Typically in a production environment, I would spend a lot of time on the front-end, so doing this kind of 'back-end first' approach is actually a bit abnormal for me now.

The logic for this project is largely contained in two routes:

    1. '/login'
    2. '/dashboard'

It is worth noting that the '/' route only functions as a reroute to either of those two routes for the purposes of this app.

Here is an overview of some of the general values / components which often see use between components:

### `'client/util':`

#### `apiClient.js:`
Contains a boilerplate version of the API call syntax to allow for reusability

#### `authApi.js:`
Contains all API calls relating to user authentication.

#### `noteApi.js:`
Contains all API calls relating to notes.

#### `InputValidators.js:`
Stateless functions for validating inputs so that logic doesn't have to be reused. All functions inside of the file aren't currently in use as it's copied over from another project of mine.

### `'client/components/general':`

#### `Error / Success Message:`
Both of these have identical logic, rendering only if the corresponding 'error' or 'success' prop is passed to them as 'true'.
Renders a message of the corresponding color as needed

### `'client/constants':`

Constants will not always be viewed in multiple locations, but are still important to have separated out for logical consistency.

#### `'DashboardViewModes.js':`
Contains the display values for the <DashboardNav/> component.
Note:
This is an instance where multiple objects will want to have access to these values (parent Dashboard route), so putting them in one centralized place is more logical.

#### `'NoteSizes.js':`
Contains the max length values for both the title and body of the Note object.
Note:
Having this in its own file helps with clarity.

#### `'NoteViewModes.js':`
Contains the view modes for the Note component.

## 4.1. '/login':

In hindsight, trying to do a fully featured login system was probably a bit over the top for the scope of this project. However, since I decided to do it I wanted to do it properly and having objects sitting in a database with no regard for ownership felt wrong to me so I at least wanted to add some associated ownership.

The front-end logic is primarily controlled by a boolean 'loginShowing', which dictates which of the following two components are showing:

***`LoginForm Inputs:`***
- email (React State String)
- password (React State String)
- setEmail (React Set Function)
- setPassword (React Set Function)
- onSubmit (Custom function to handle user login)
- updateError (Custom function to handle error display in parent component)


***`SignupForm Inputs:`***
- email={signupEmail}
- username (React State String)
- password (React State String)
- confirmPassword (React State String)
- setEmail (React Set Function)
- setUsername (React Set Function)
- setPassword (React Set Function)
- setConfirmPassword (React Set Function)
- onSubmit (Custom function to handle user signup)
- updateError (Custom function to handle error display in parent component)

Both components exist as a container for the login / signup form inputs to help with code clarity. The majority of logic (non-input validating) is handled by the parent component.


Before passing data to their corresponding API calls via the parent component, the InputValidators.js file is put to use by verifying fields such as: email, username, password, as well as checking that password and confirmPassword values match. If not, the setError value is updated which is then passed down to the aforementioned general component ErrorMessage.js to display what went wrong.
Additionally, this component is put to use when the server returns a code indicating an error.

On successful signup or login, the users token is saved to local storage and they are redirected to the dashboard route after a small delay (such that they can process the success message).


## 4.2. '/dashboard':

On load, the dashboard route will run an identical API call from the '/' route to verify the user is logged in and get their corresponding object. React will then use the update of the 'user' object tied to a corresponding useEffect call as a trigger to call the getUserNotes function call from 'noteApi.js'.

After both are verified, the dashboard can load.

The Dashboard is where all CRUD functionality is contained:

### C (Create):
Click on Create Note to trigger the loading of the CreateNote.js component.
Here the user can add a note to the database and their account.
The user object is reloaded on note submission so the local entries array rendering the note is updated after the user submits their note, therefore leading us to the next function.

### R (Read):
Click on 'View Notes' to view all notes belonging to the user.
If there is no notes associated with the user, by default the front-end will render a line informing the user that they do not have any notes.
As this is a demonstration app there is no limit on how many notes a user can have in their database, but in a production setting this would likely be a variable shared between both the client and the server to ensure uniform enforcement.

### U (Update):
In the 'View Notes' section, you can click on the 'Edit' button which will change the Note.js components internal display value to 'VIEW_MODES.EDITING', transforming the displays of the values into editable text boxes. After any desired changes have been made, click on submit changes to update the database and user object.

### D (Delete):
In the 'View Notes' section, you can click on "Delete Note" which will give the user a yes/no prompt.
If you click yes then your note will be deleted using the 'delete-note' api call.

Additionally in the '/dashboard' route there are some functions like updateNoteByKey which are used to synchronize local state changes with the corresponding server-side updates.

The Note component handles the majority of the logic for the Read & Update & Delete functions while the Create function is outsourced to the CreateNote component. There is certainly ways to put all of their functionality together into one, but for clarity I prefer the approach of keeping the Create function separated in this case.


